<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ASTRODEEP Explorer</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<!-- Librerie Esterne -->
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.0/umd/index.min.js"></script>

<style>
    /* STILI CSS */
    :root { --bg-sidebar: #0f172a; --text-sidebar: #f1f5f9; --accent: #3b82f6; --bg-main: #f8fafc; --card-bg: #ffffff; --text-main: #1e293b; --border: #e2e8f0; }
    body { font-family: 'Inter', sans-serif; margin: 0; padding: 0; background: var(--bg-main); color: var(--text-main); height: 100vh; display: flex; overflow: hidden; }
    
    /* Sidebar */
    .sidebar { width: 320px; background: var(--bg-sidebar); color: var(--text-sidebar); display: flex; flex-direction: column; padding: 1.5rem; overflow-y: auto; flex-shrink: 0; z-index: 20; border-right:1px solid #1e293b; }
    .sidebar-header { margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #334155; }
    .sidebar-header h1 { font-size: 1.2rem; margin: 0; font-weight: 700; color:white; }
    
    /* Controlli */
    .control-group { margin-bottom: 1.2rem; }
    .control-label { font-size: 0.7rem; text-transform: uppercase; color: #94a3b8; margin-bottom: 0.4rem; font-weight: 600; display: block; }
    select { width: 100%; background: #1e293b; color: #f8fafc; border: 1px solid #334155; padding: 0.5rem; border-radius: 0.4rem; font-size: 0.85rem; outline: none; }
    select:focus { border-color: var(--accent); }
    select[multiple] { height: 120px; }
    .btn { background: var(--accent); color: white; border: none; padding: 0.6rem; border-radius: 0.4rem; cursor: pointer; font-weight: 600; width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem; font-size: 0.9rem; margin-top:0.5rem; transition: filter 0.2s; }
    .btn:hover { filter: brightness(1.1); }
    .btn-secondary { background: #334155; font-size: 0.75rem; padding: 0.3rem; width: auto; flex-grow: 1; margin-top:0.3rem; }
    
    /* Toggles */
    .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.85rem; }
    .switch { position: relative; display: inline-block; width: 32px; height: 18px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #334155; transition: .4s; border-radius: 18px; }
    .slider:before { position: absolute; content: ""; height: 12px; width: 12px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider { background-color: var(--accent); }
    input:checked + .slider:before { transform: translateX(14px); }
    
    /* Layout Principale */
    .main-content { flex-grow: 1; padding: 1rem; display: grid; grid-template-rows: 60% 1fr; gap: 1rem; height: 100vh; overflow: hidden; }
    .card { background: var(--card-bg); border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); border: 1px solid var(--border); position: relative; display: flex; flex-direction: column; overflow: hidden; }
    .card-header { padding: 0.6rem 1rem; background: #f8fafc; border-bottom: 1px solid var(--border); font-weight: 600; font-size: 0.85rem; display: flex; justify-content: space-between; align-items: center; color: #334155; }
    .plot-area { flex-grow: 1; position: relative; min-height: 0; }
    
    /* Loading Screen */
    #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #f8fafc; z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; color: var(--text-main); text-align: center; }
    .progress-container { width: 300px; background: #e2e8f0; border-radius: 4px; height: 8px; margin-top: 1rem; overflow: hidden; }
    .progress-bar { height: 100%; background: var(--accent); width: 0%; transition: width 0.2s; }
</style>
</head>
<body>

<div id="loading">
    <h2 style="margin-bottom:0.5rem">Inizializzazione Dati</h2>
    <p id="loadingText" style="color:#64748b; font-size:0.9rem">Download datasets...</p>
    <div class="progress-container"><div class="progress-bar" id="pBar"></div></div>
</div>

<aside class="sidebar">
    <div class="sidebar-header">
        <h1>ASTRODEEP <span style="font-weight:300; font-size:0.8em; opacity:0.8">JWST</span></h1>
    </div>
    
    <div class="control-group">
        <label class="control-label" style="color:var(--accent)">1. Datasets</label>
        <select id="surveySelect" multiple></select>
        <div class="btn-group">
            <button id="selAll" class="btn btn-secondary">Tutti</button>
            <button id="selNone" class="btn btn-secondary">Nessuno</button>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label">2. Assi Grafico</label>
        <select id="xVar" style="margin-bottom:0.4rem"></select>
        <select id="yVar" style="margin-bottom:0.4rem"></select>
        <select id="zVar" style="display:none; margin-bottom:0.4rem"></select>
        
        <div class="toggle-row" style="margin-top:0.5rem">
            <select id="plotType" style="width:60%"><option value="scatter2d">Scatter 2D</option><option value="hist">Istogramma</option><option value="scatter3d">Scatter 3D</option></select>
            <div style="font-size:0.8rem; color:#94a3b8">Scala Log</div>
        </div>
         <div class="toggle-row">
            <span>Asse X</span><label class="switch"><input type="checkbox" id="logX"><span class="slider"></span></label>
            <span style="margin-left:10px">Asse Y</span><label class="switch"><input type="checkbox" id="logY" checked><span class="slider"></span></label>
        </div>
        <button id="updatePlot" class="btn"><i class="fa-solid fa-rotate"></i> Aggiorna Plot</button>
    </div>

    <hr style="border:0; border-top:1px solid #334155; margin: 1rem 0;">

    <div class="control-group">
        <label class="control-label" style="color:#ec4899">3. Analisi PCA</label>
        <select id="pcaVars" multiple style="height:100px"></select>
        <div class="toggle-row" style="margin-top:0.6rem"><span>3D PCA</span><label class="switch"><input type="checkbox" id="pca3D"><span class="slider"></span></label></div>
        <button id="runPCA" class="btn" style="background:#ec4899"><i class="fa-solid fa-microchip"></i> Calcola PCA</button>
    </div>
</aside>

<main class="main-content">
    <div class="card">
        <div class="card-header"><span><i class="fa-solid fa-chart-line"></i> Esplorazione</span><span id="mainStats"></span></div>
        <div id="plot" class="plot-area"></div>
    </div>
    <div class="card">
        <div class="card-header"><span><i class="fa-solid fa-project-diagram"></i> Spazio PCA</span><span id="pcaStats"></span></div>
        <div id="pca-plot" class="plot-area"></div>
    </div>
</main>

<script>
// =========================================================================
// INCOLLA QUI SOTTO IL JSON GENERATO DA PYTHON
// DEVE ESSERE NEL FORMATO: [ { "name": "...", "file": "data/..." }, ... ]
// =========================================================================

const SURVEY_MANIFEST = [
    {
        "name": "A2744O",
        "file": "data/A2744O.csv.gz"
    },
    {
        "name": "CEERSO",
        "file": "data/CEERSO.csv.gz"
    },
    {
        "name": "JADESGNO",
        "file": "data/JADESGNO.csv.gz"
    },
    {
        "name": "JADESGSO",
        "file": "data/JADESGSO.csv.gz"
    },
    {
        "name": "NGDEEPO",
        "file": "data/NGDEEPO.csv.gz"
    },
    {
        "name": "PRIMERCO",
        "file": "data/PRIMERCO.csv.gz"
    },
    {
        "name": "PRIMERUO",
        "file": "data/PRIMERUO.csv.gz"
    }
];

// =========================================================================

// Strutture Dati
let db = {}; // Dati grezzi
let surveyCols = {}; // Mappa: NomeSurvey -> Set di colonne disponibili

document.addEventListener("DOMContentLoaded", async () => {
    
    if (SURVEY_MANIFEST.length === 0) {
        alert("JSON MANCANTE: Incolla il SURVEY_MANIFEST nel codice!");
        return;
    }

    let loaded = 0;
    
    const loadFile = async (item) => {
        try {
            const response = await fetch(item.file);
            if(!response.ok) throw new Error("404 Not Found");
            
            const buffer = await response.arrayBuffer();
            const decompressed = fflate.decompressSync(new Uint8Array(buffer));
            const text = new TextDecoder("utf-8").decode(decompressed);
            
            const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
            
            db[item.name] = parsed.data;
            
            // Mappa le colonne per questa specifica survey
            if(parsed.data.length > 0) {
                const keys = Object.keys(parsed.data[0]).filter(k => !["survey","ID","Flag"].includes(k));
                surveyCols[item.name] = new Set(keys);
            }
        } catch(e) {
            console.warn(`Skip ${item.name}: ${e.message}`);
        } finally {
            loaded++;
            const pct = (loaded / SURVEY_MANIFEST.length) * 100;
            document.getElementById("pBar").style.width = pct + "%";
            document.getElementById("loadingText").innerText = `Caricamento ${loaded}/${SURVEY_MANIFEST.length}...`;
        }
    };

    await Promise.all(SURVEY_MANIFEST.map(item => loadFile(item)));
    
    document.getElementById("loading").style.display = "none";
    initUI();
});

function initUI() {
    const sSelect = document.getElementById("surveySelect");
    
    // 1. Popola Survey
    SURVEY_MANIFEST.forEach(s => {
        if(db[s.name]) { 
            const opt = document.createElement("option");
            opt.value = s.name; opt.textContent = s.name; opt.selected = true;
            sSelect.appendChild(opt);
        }
    });

    // 2. Listener Fondamentale: Quando cambiano le survey, ricalcola le variabili
    sSelect.addEventListener("change", updateAvailableVariables);
    
    // Bottoni selezione
    document.getElementById("selAll").onclick = () => { 
        Array.from(sSelect.options).forEach(o=>o.selected=true); 
        updateAvailableVariables(); // Aggiorna variabili
        drawPlot(); 
    };
    document.getElementById("selNone").onclick = () => { 
        Array.from(sSelect.options).forEach(o=>o.selected=false); 
        updateAvailableVariables();
        drawPlot(); 
    };

    // Altri listener
    document.getElementById("updatePlot").onclick = drawPlot;
    document.getElementById("runPCA").onclick = runPCA;
    document.getElementById("plotType").addEventListener("change", (e) => {
        document.getElementById("zVar").style.display = (e.target.value === "scatter3d") ? "block" : "none";
    });

    // Prima inizializzazione
    updateAvailableVariables();
    
    // Imposta default (se esistono nelle variabili comuni)
    setDefaultVars();
    drawPlot();
}

// --- LOGICA CORE: Intersezione delle Variabili ---
function updateAvailableVariables() {
    const sSelect = document.getElementById("surveySelect");
    const selectedSurveys = Array.from(sSelect.selectedOptions).map(o => o.value);
    
    if (selectedSurveys.length === 0) {
        fillSelects([]); // Pulisci tutto se nulla è selezionato
        return;
    }

    // Algoritmo Intersezione: Prendi le colonne della prima survey e tieni solo quelle presenti anche nelle altre
    // 1. Inizia con le colonne della prima survey selezionata
    let commonVars = Array.from(surveyCols[selectedSurveys[0]] || []);

    // 2. Filtra contro tutte le altre survey selezionate
    for (let i = 1; i < selectedSurveys.length; i++) {
        const sName = selectedSurveys[i];
        const cols = surveyCols[sName]; // Il Set delle colonne di questa survey
        if (cols) {
            commonVars = commonVars.filter(c => cols.has(c));
        }
    }

    commonVars.sort();

    // 3. Aggiorna i menu a tendina
    // Nota: Passiamo true al secondo parametro per cercare di mantenere la selezione corrente dell'utente
    fillSelects(commonVars);
}

function fillSelects(vars) {
    const targets = ["xVar", "yVar", "zVar", "pcaVars"];
    
    targets.forEach(id => {
        const el = document.getElementById(id);
        
        // Salva selezione precedente
        const oldVal = Array.from(el.selectedOptions).map(o => o.value);
        
        el.innerHTML = "";
        
        vars.forEach(c => {
            const opt = document.createElement("option");
            opt.value = c; 
            opt.textContent = c;
            // Ripristina selezione se la variabile esiste ancora
            if (oldVal.includes(c)) opt.selected = true;
            el.appendChild(opt);
        });
    });
}

function setDefaultVars() {
    // Prova a settare default intelligenti solo se non è già stato selezionato nulla
    const xEl = document.getElementById("xVar");
    const yEl = document.getElementById("yVar");

    if (xEl.options.length > 0 && xEl.selectedIndex === -1) {
        // Cerca zphot o zspec
        for(let opt of xEl.options) {
            if(opt.value.toLowerCase().includes("zphot")) { opt.selected = true; break; }
        }
        if (xEl.selectedIndex === -1) xEl.options[0].selected = true;
    }

    if (yEl.options.length > 0 && yEl.selectedIndex === -1) {
        // Cerca Fauto o 444
        for(let opt of yEl.options) {
            if(opt.value.includes("Fauto") || opt.value.includes("444")) { opt.selected = true; break; }
        }
        if (yEl.selectedIndex === -1 && yEl.options.length > 1) yEl.options[1].selected = true;
    }
}

// --- PLOTTING ---
function drawPlot() {
    const config = {
        type: document.getElementById("plotType").value,
        x: document.getElementById("xVar").value,
        y: document.getElementById("yVar").value,
        z: document.getElementById("zVar").value,
        logX: document.getElementById("logX").checked,
        logY: document.getElementById("logY").checked,
        surveys: Array.from(document.getElementById("surveySelect").selectedOptions).map(o=>o.value)
    };

    if(config.surveys.length === 0 || !config.x) {
        Plotly.newPlot("plot", [], {title: "Seleziona Dati e Variabili"});
        return;
    }

    const is3D = config.type === "scatter3d";
    const isHist = config.type === "hist";
    let traces = [];
    let totalPoints = 0;

    config.surveys.forEach(sName => {
        const data = db[sName];
        if(!data) return;

        let xData = [], yData = [], zData = [];
        
        for(let i=0; i<data.length; i++) {
            const row = data[i];
            
            const vx = row[config.x];
            if(typeof vx !== 'number' || !Number.isFinite(vx)) continue;
            if(config.logX && vx <= 0) continue;

            let vy = 0, vz = 0;
            if(!isHist) {
                vy = row[config.y];
                if(typeof vy !== 'number' || !Number.isFinite(vy)) continue;
                if(config.logY && vy <= 0) continue;
            }
            if(is3D) {
                vz = row[config.z];
                if(typeof vz !== 'number' || !Number.isFinite(vz)) continue;
            }

            xData.push(vx);
            if(!isHist) yData.push(vy);
            if(is3D) zData.push(vz);
        }

        if(xData.length > 0) {
            totalPoints += xData.length;
            let trace = { name: sName, x: xData, opacity: 0.7 };
            if(isHist) { trace.type = 'histogram'; }
            else if(is3D) { trace.type = 'scatter3d'; trace.mode = 'markers'; trace.y = yData; trace.z = zData; trace.marker = { size: 2 }; }
            else { trace.type = 'scattergl'; trace.mode = 'markers'; trace.y = yData; trace.marker = { size: 4, opacity: 0.6 }; }
            traces.push(trace);
        }
    });

    document.getElementById("mainStats").textContent = `${totalPoints.toLocaleString()} obj`;

    const layout = {
        font: { family: 'Inter, sans-serif' },
        margin: { l:50, r:20, t:30, b:40 },
        showlegend: true, legend: { x: 1.02, y: 1 },
        paper_bgcolor: "transparent", plot_bgcolor: "transparent",
        xaxis: { title: config.x, type: config.logX?'log':'linear', gridcolor:'#e2e8f0' },
        yaxis: { title: isHist?"Count":config.y, type: config.logY?'log':'linear', gridcolor:'#e2e8f0' }
    };
    if(isHist) { layout.barmode='overlay'; layout.bargap=0.05; }
    if(is3D) layout.scene = { xaxis:{title:config.x}, yaxis:{title:config.y}, zaxis:{title:config.z} };

    Plotly.newPlot("plot", traces, layout, {responsive:true, scrollZoom:true});
}

// --- PCA ---
function runPCA() {
    const selVars = Array.from(document.getElementById("pcaVars").selectedOptions).map(o=>o.value);
    const selSurveys = Array.from(document.getElementById("surveySelect").selectedOptions).map(o => o.value);
    const is3D = document.getElementById("pca3D").checked;

    if(selVars.length < 2) { alert("Seleziona almeno 2 variabili per la PCA."); return; }
    if(selSurveys.length === 0) return;

    document.getElementById("pcaStats").textContent = "Calcolo PCA in corso...";
    
    setTimeout(() => {
        try {
            let dataMatrix = [], surveysMap = [];
            
            selSurveys.forEach(sName => {
                const data = db[sName];
                if(!data) return;

                for(let i=0; i<data.length; i++) {
                    const row = data[i];
                    let rowVec = [], valid = true;
                    for(let v of selVars) {
                        const val = row[v];
                        if(typeof val !== 'number' || !Number.isFinite(val)) { valid=false; break; }
                        rowVec.push(val);
                    }
                    if(valid) { dataMatrix.push(rowVec); surveysMap.push(sName); }
                }
            });

            if(dataMatrix.length < 10) { 
                alert("Errore: Dati insufficienti. Assicurati che le variabili selezionate abbiano valori validi (non NaN) per le survey scelte."); 
                document.getElementById("pcaStats").textContent = "Dati insufficienti.";
                return; 
            }
            
            // Standardizzazione
            const N = dataMatrix.length, D = selVars.length;
            let means = new Array(D).fill(0), vars = new Array(D).fill(0);

            for(let i=0; i<N; i++) for(let j=0; j<D; j++) means[j] += dataMatrix[i][j];
            for(let j=0; j<D; j++) means[j] /= N;
            for(let i=0; i<N; i++) for(let j=0; j<D; j++) vars[j] += (dataMatrix[i][j] - means[j])**2;
            let stds = vars.map(v => Math.sqrt(v / (N-1))).map(v => v===0?1:v);

            for(let i=0; i<N; i++) for(let j=0; j<D; j++) dataMatrix[i][j] = (dataMatrix[i][j] - means[j]) / stds[j];

            // Covarianza
            let cov = Array(D).fill(0).map(() => Array(D).fill(0));
            for(let r=0; r<D; r++) for(let c=r; c<D; c++) {
                let sum = 0; for(let i=0; i<N; i++) sum += dataMatrix[i][r] * dataMatrix[i][c];
                cov[r][c] = sum / (N-1); cov[c][r] = cov[r][c];
            }

            // Eigen Decomposition
            const { eigenValues, eigenVectors } = jacobi(cov);
            let indices = Array.from(Array(D).keys()).sort((a,b) => eigenValues[b] - eigenValues[a]);
            const totalVar = eigenValues.reduce((a,b) => a+b, 0);
            const varExp = indices.map(i => ((eigenValues[i] / totalVar) * 100).toFixed(1));

            // Proiezione
            let pc1=[], pc2=[], pc3=[];
            const v1 = indices[0], v2 = indices[1], v3 = indices[2];

            for(let i=0; i<N; i++) {
                let d1=0, d2=0, d3=0;
                for(let j=0; j<D; j++) {
                    d1 += dataMatrix[i][j] * eigenVectors[j][v1];
                    d2 += dataMatrix[i][j] * eigenVectors[j][v2];
                    if(is3D) d3 += dataMatrix[i][j] * eigenVectors[j][v3];
                }
                pc1.push(d1); pc2.push(d2); if(is3D) pc3.push(d3);
            }

            // Plot
            let pcaTraces = [], buckets = {};
            selSurveys.forEach(s => buckets[s] = {x:[], y:[], z:[]});

            for(let i=0; i<N; i++) {
                const s = surveysMap[i];
                if(buckets[s]) { buckets[s].x.push(pc1[i]); buckets[s].y.push(pc2[i]); if(is3D) buckets[s].z.push(pc3[i]); }
            }

            selSurveys.forEach(s => {
                const d = buckets[s];
                if(d.x.length === 0) return;
                let trace = { name: s, x: d.x, y: d.y, mode: 'markers', type: is3D ? 'scatter3d' : 'scattergl', marker: { size: is3D ? 2 : 4, opacity: 0.6 } };
                if(is3D) trace.z = d.z;
                pcaTraces.push(trace);
            });

            const layout = {
                title: false,
                xaxis: { title: `PC1 (${varExp[0]}%)`, gridcolor:'#e2e8f0' },
                yaxis: { title: `PC2 (${varExp[1]}%)`, gridcolor:'#e2e8f0' },
                font: { family: 'Inter, sans-serif' }, margin: { l:50, r:20, t:30, b:40 },
                showlegend: true, paper_bgcolor: "transparent", plot_bgcolor: "transparent"
            };
            if(is3D) layout.scene = { xaxis: { title: `PC1` }, yaxis: { title: `PC2` }, zaxis: { title: `PC3` } };

            Plotly.newPlot("pca-plot", pcaTraces, layout, {responsive:true});
            document.getElementById("pcaStats").textContent = `PC1+2: ${Number(varExp[0]) + Number(varExp[1])}% Var`;

        } catch (e) { console.error(e); alert("Errore Critico PCA: " + e.message); }
    }, 50);
}

function jacobi(A) {
    const n = A.length;
    let V = Array(n).fill(0).map((_, i) => Array(n).fill(0).map((_, j) => (i === j ? 1 : 0)));
    let D = A.map(row => row.slice());
    for (let iter = 0; iter < 80; iter++) {
        let maxOff = 0, p = 0, q = 0;
        for (let i = 0; i < n; i++) for (let j = i + 1; j < n; j++) if (Math.abs(D[i][j]) > maxOff) { maxOff = Math.abs(D[i][j]); p = i; q = j; }
        if (maxOff < 1e-8) break;
        const phi = (D[q][q] - D[p][p]) / (2 * D[p][q]);
        const t = Math.sign(phi) / (Math.abs(phi) + Math.sqrt(phi * phi + 1));
        const c = 1 / Math.sqrt(1 + t * t), s = c * t;
        const temp = D[p][p];
        D[p][p] = c*c*temp + s*s*D[q][q] - 2*c*s*D[p][q]; D[q][q] = s*s*temp + c*c*D[q][q] + 2*c*s*D[p][q]; D[p][q] = 0; D[q][p] = 0;
        for (let i = 0; i < n; i++) if (i !== p && i !== q) { const Dip = D[i][p], Diq = D[i][q]; D[i][p] = c*Dip - s*Diq; D[p][i] = D[i][p]; D[i][q] = s*Dip + c*Diq; D[q][i] = D[i][q]; }
        for (let i = 0; i < n; i++) { const Vip = V[i][p], Viq = V[i][q]; V[i][p] = c*Vip - s*Viq; V[i][q] = s*Vip + c*Viq; }
    }
    let eigenValues = []; for(let i=0; i<n; i++) eigenValues.push(D[i][i]);
    return { eigenValues, eigenVectors: V };
}
</script>
</body>
</html>
